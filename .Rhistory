psi_init[,i] = as.numeric(psi_init[,i]/sum(psi_init[,i]))
}
}
#------ phi ------
if (init_con_phi ==1){
#K1 = K
#K2 = K
#phi_init = matrix(rgamma(K1*K2,shape=alpha_phi),K1,K2) #randg(alpha_psi,P,K)
oness = matrix(1,K,K)
diag(oness) = 0
matt = diag(K)*.8 + oness*(.2/(K-1))
phi_init=rdirichlet(3,matt)
# for (i in 1:K2){
#   phi_init[,i] = phi_init[,i]/sum(phi_init[,i])
#}
} else if (init_con_phi ==2){
phi_init = phi_tru
}
#------ W ------
if (init_con_W ==1){
W_init<-array(dim=c(K,numTotal))
for (n in 1:numTotal){
for (k in 1:K){
W_init[k,n] = rgamma(1,3,0.5)
}
}
} else if (init_con_W ==2){
W_init = w_tru
}
#------ theta ------
if (init_con_theta ==1){
theta_init<-array(dim=c(K,numTotal))
for (n in 1:numTotal){
for (k in 1:K){
theta_init[k,n] = rgamma(1,3,0.5)
}
}
} else if (init_con_theta ==2){
theta_init = theta_tru
}
#------ H ------
if (init_con_H ==1){
H_init<-array(rbinom(N*numTime,1, 0.5),dim=c(K,numTotal))
} else if (init_con_H ==2){
H_init = H_tru
} else if (init_con_H ==3){
H_init = array(1, dim=c(K,numTotal))
}
inits = list(psi_init, phi_init, theta_init, W_init, H_init)
}
inits <- init_vals(M,
K,
N,
data,
numTime,
numTotal,
alpha_psi,
alpha_phi,
init_con_psi=init_con,
init_con_phi=init_con,
init_con_W=init_con,
init_con_theta=init_con,
init_con_H)#,
init_con=1
inits <- init_vals(M,
K,
N,
data,
numTime,
numTotal,
alpha_psi,
alpha_phi,
init_con_psi=init_con,
init_con_phi=init_con,
init_con_W=init_con,
init_con_theta=init_con,
init_con_H)#,
alpha_psi=1
inits <- init_vals(M,
K,
N,
data,
numTime,
numTotal,
alpha_psi,
alpha_phi,
init_con_psi=init_con,
init_con_phi=init_con,
init_con_W=init_con,
init_con_theta=init_con,
init_con_H)#,
init_con_H=1
inits <- init_vals(M,
K,
N,
data,
numTime,
numTotal,
alpha_psi,
alpha_phi,
init_con_psi=init_con,
init_con_phi=init_con,
init_con_W=init_con,
init_con_theta=init_con,
init_con_H)#,
psi_init = inits[[1]]
phi_init = inits[[2]]
theta_init = inits[[3]]
W_init = inits[[4]]
H_init = inits[[5]]
Psi = psi_init
Phi = phi_init
Theta = theta_init
W = W_init
ZZip = H_init
ZZip
summary(t(ZZip))
unique(t(ZZip))
b=1
out = mult_cpp(Xmtot,Psi,Theta, ZZip)
rztpois_single <- function(lambda) {
.Call(`_dpfa_rztpois_single`, lambda)
}
rztpois_cpp <- function(n, lambda) {
.Call(`_dpfa_rztpois_cpp`, n, lambda)
}
calcC_kn <- function(ZZip_3D, bias_0, W_3D, Phi) {
.Call(`_dpfa_calcC_kn`, ZZip_3D, bias_0, W_3D, Phi)
}
calcTheta <- function(rk, ZZip, x_kn, p0) {
.Call(`_dpfa_calcTheta`, rk, ZZip, x_kn, p0)
}
calcW <- function(sk, ZZip, C_k1n, p0) {
.Call(`_dpfa_calcW`, sk, ZZip, C_k1n, p0)
}
mult_cpp <- function(X_mtn, Psi, Theta, ZZip) {
.Call(`_dpfa_mult_cpp`, X_mtn, Psi, Theta, ZZip)
}
crt_cpp <- function(X_kn, rk) {
.Call(`_dpfa_crt_cpp`, X_kn, rk)
}
out = mult_cpp(Xmtot,Psi,Theta, ZZip)
W_time = sweep(W,2,timeSpan,'/')
W_3D = matrix_to_array(W_time, K, numSample,numTime)
ZZip_3D = matrix_to_array(ZZip,K, numSample,numTime)
C_kn <- calcC_kn(ZZip_3D, bias_0, W_3D, Phi)
ZZip_3D = matrix_to_array(ZZip,K, numSample,numTime)
matrix_to_array = function(matrix,K, numSample, numTime){
output = array(NA, dim = c(K, numTime, numSample))
for (i in 1:numSample){
output[,,i]= matrix[,(numTime*i-(numTime-1)):(numTime*i)]
}
return(output)
}
W_3D = matrix_to_array(W_time, K, numSample,numTime)
ZZip_3D = matrix_to_array(ZZip,K, numSample,numTime)
ZZip_3D
C_kn <- calcC_kn(ZZip_3D, bias_0, W_3D, Phi)
dpfa.out$ZZip_est
unique(t(dpfa.out$ZZip_est))
p_1 = .4
p_0=.1
((p_1/( p_1 + p_0 ) )
rix=2
((p_1/( p_1 + p_0 ) ) > runif(length(rix)))
((p_1/( p_1 + p_0 ) ) > runif(length(rix)))
((p_1/( p_1 + p_0 ) ) > runif(length(rix)))
?runif
dpfa.out$ZZip_est
dpfa.out$ZZip_est[1:3,1;10]
dpfa.out$ZZip_est[1:3,1:10]
dpfa.out$ZZip_est[1:3,1:30]
library(dpfa)
# vector memory limit at 10000 iters
# need 5000 iters
dpfa.out = dpfa(data,
K=3,
N=30,
M=15,
alpha_phi=5,
numTime=100,
niter=2,
init_con_H=1)
library(dpfa)
# vector memory limit at 10000 iters
# need 5000 iters
dpfa.out = dpfa(data,
K=3,
N=30,
M=15,
alpha_phi=5,
numTime=100,
niter=2,
init_con_H=1)
library(dpfa)
# vector memory limit at 10000 iters
# need 5000 iters
dpfa.out = dpfa(data,
K=3,
N=30,
M=15,
alpha_phi=5,
numTime=100,
niter=2,
init_con_H=1)
NA > .3
(NA > .3)*1
library(dpfa)
# vector memory limit at 10000 iters
# need 5000 iters
dpfa.out = dpfa(data,
K=3,
N=30,
M=15,
alpha_phi=5,
numTime=100,
niter=2,
init_con_H=1)
# vector memory limit at 10000 iters
# need 5000 iters
dpfa.out = dpfa(data,
K=3,
N=30,
M=15,
alpha_phi=5,
numTime=100,
niter=20,
init_con_H=1)
library(dpfa)
# vector memory limit at 10000 iters
# need 5000 iters
dpfa.out = dpfa(data,
K=3,
N=30,
M=15,
alpha_phi=5,
numTime=100,
niter=20,
init_con_H=1)
warnings()
library(dpfa)
# vector memory limit at 10000 iters
# need 5000 iters
dpfa.out = dpfa(data,
K=3,
N=30,
M=15,
alpha_phi=5,
numTime=100,
niter=20,
init_con_H=1)
library(dpfa)
# vector memory limit at 10000 iters
# need 5000 iters
dpfa.out = dpfa(data,
K=3,
N=30,
M=15,
alpha_phi=5,
numTime=100,
niter=20,
init_con_H=1)
library(dpfa)
# vector memory limit at 10000 iters
# need 5000 iters
dpfa.out = dpfa(data,
K=3,
N=30,
M=15,
alpha_phi=5,
numTime=100,
niter=20,
init_con_H=1)
library(dpfa)
library(dpfa)
# vector memory limit at 10000 iters
# need 5000 iters
dpfa.out = dpfa(data,
K=3,
N=30,
M=15,
alpha_phi=5,
numTime=100,
niter=20,
init_con_H=1)
dpfa.out$psi_est
dpfa.out$phi_est
summary(t(dpfa.out$ZZip_est))
unique(t(dpfa.out$ZZip_est))
library(dpfa)
# vector memory limit at 10000 iters
# need 5000 iters
dpfa.out = dpfa(data,
K=3,
N=30,
M=15,
alpha_phi=5,
numTime=100,
niter=20,
init_con_H=1)
library(dpfa)
# vector memory limit at 10000 iters
# need 5000 iters
dpfa.out = dpfa(data,
K=3,
N=30,
M=15,
alpha_phi=5,
numTime=100,
niter=2000,
init_con_H=1)
?mode
library(dpfa)
# vector memory limit at 10000 iters
# need 5000 iters
dpfa.out = dpfa(data,
K=3,
N=30,
M=15,
alpha_phi=5,
numTime=100,
niter=20,
init_con_H=1)
dpfa.out$ZZip_est
dpfa.out$ZZip_est[1:3,1:3]
summary(t(dpfa.out$ZZip_est))
# vector memory limit at 10000 iters
# need 5000 iters
dpfa.out = dpfa(data,
K=3,
N=30,
M=15,
alpha_phi=5,
numTime=100,
niter=2000,
init_con_H=1)
summary(t(dpfa.out$ZZip_est))
summary(t(dpfa.out$H_tru))
str(ret)
summary(t(ret[[4]]))
h_tru ret[[4]]
h_tru = ret[[4]]
zzip dpfa.out$ZZip_est
zzip = dpfa.out$ZZip_est
zzip == h_tru
mean(zzip == h_tru)
dpfa.out$W_est
summary(t(dpfa.out$W_est))
w_tru = ret[[5]]
summary(t(dpfa.out$w_tru))
w_tru = ret[[5]]
str(w_tru)
summary(t(w_tru))
summary(t(dpfa.out$W_est))
rgamma(1,3,0.5)
rgamma(1,3,0.5)
rgamma(1,3,0.5)
rgamma(1,3,0.5)
rgamma(1,3,0.5)
rgamma(1,3,0.5)
rgamma(1,3,0.5)
rgamma(1,3,0.5)
rgamma(1,3,0.5)
rgamma(1,3,0.5)
rgamma(1,3,0.5)
rgamma(1,3,0.5)
rgamma(1,3,0.5)
rgamma(1,3,0.5)
rgamma(1,3,0.5)
rgamma(1,3,0.5)
rgamma(1,3,0.5)
rgamma(1,3,0.5)
rgamma(1,3,0.5)
rgamma(1,3,0.5)
rgamma(1,3,0.5)
rgamma(1,3,0.5)
rgamma(1,3,0.5)
rgamma(1,3,0.5)
rgamma(1,3,0.5)
rgamma(1,3,0.5)
rgamma(1,3,0.5)
summary(t(dpfa.out$W_est))
library(dpfa)
# vector memory limit at 10000 iters
# need 5000 iters
dpfa.out = dpfa(data,
K=3,
N=30,
M=15,
alpha_phi=5,
numTime=100,
niter=2,
init_con_H=1)
library(dpfa)
# vector memory limit at 10000 iters
# need 5000 iters
dpfa.out = dpfa(data,
K=3,
N=30,
M=15,
alpha_phi=5,
numTime=100,
niter=2,
init_con_H=1)
library(dpfa)
# vector memory limit at 10000 iters
# need 5000 iters
dpfa.out = dpfa(data,
K=3,
N=30,
M=15,
alpha_phi=5,
numTime=100,
niter=2,
init_con_H=1)
K=3
bias_0 = rep(2,K)
BPL<-function(lambda,K){
prob = 1-exp(-lambda)
out = rbern(rep(1,K),prob)
return(matrix(out, nrow = K))
}
BPL(bias_0,K)
BPL(bias_0,K)
BPL(bias_0,K)
BPL(bias_0,K)
BPL(bias_0,K)
BPL(bias_0,K)
BPL(bias_0,K)
BPL(bias_0,K)
BPL(bias_0,K)
BPL(bias_0,K)
BPL(bias_0,K)
BPL(bias_0,K)
BPL(bias_0,K)
lambda=2
1-exp(-lambda)
1-exp(-lambda)
1-exp(-lambda)
1-exp(-lambda)
1-exp(-lambda)
1-exp(-lambda)
1-exp(-lambda)
1-exp(-lambda)
ret = true_data_Cond3(K=3, numSample=30, M=15, numTime=100,bias=0)
ret = true_data_Cond3(K=3, numSample=30, M=15, numTime=100,bias_0=0)
source("true_data_Cond3.R")
ret = true_data_Cond3(K=3, numSample=30, M=15, numTime=100,bias_0=0)
ret = true_data_Cond3(K=3, numSample=30, M=15, numTime=100,bias=0)
setwd("/Volumes/GoogleDrive/Shared drives/SLAM Lab/dpfa_sim")
source("true_data_Cond3.R")
ret = true_data_Cond3(K=3, numSample=30, M=15, numTime=100,bias=0)
h_tru = ret[[4]]
summary(t(h_tru))
bias_0 = rep(bias,K)
bias=0
bias_0 = rep(bias,K)
BPL(bias_0,K)
BPL(bias_0,K)
BPL(bias_0,K)
BPL(bias_0,K)
BPL(bias_0,K)
lambda=0
1-exp(-lambda)
1-exp(-lambda)
1-exp(-lambda)
1-exp(-lambda)
lambda=.2
1-exp(-lambda)
1-exp(-lambda)
1-exp(-lambda)
1-exp(-lambda)
1-exp(-lambda)
1-exp(-lambda)
1-exp(-lambda)
ret = true_data_Cond3(K=3, numSample=30, M=15, numTime=100,bias=0.5)
h_tru = ret[[4]]
summary(t(h_tru))
# vector memory limit at 10000 iters
# need 5000 iters
dpfa.out = dpfa(data,
K=3,
N=30,
M=15,
alpha_phi=5,
numTime=100,
niter=2,
init_con_H=1)
library(dpfa)
# vector memory limit at 10000 iters
# need 5000 iters
dpfa.out = dpfa(data,
K=3,
N=30,
M=15,
alpha_phi=5,
numTime=100,
niter=2,
init_con_H=1)
# vector memory limit at 10000 iters
# need 5000 iters
dpfa.out = dpfa(data,
K=3,
N=30,
M=15,
alpha_phi=5,
numTime=100,
niter=2000,
init_con_H=1)
summary(t(dpfa.out$ZZip_est))
dpfa.out$psi_est
dpfa.out$phi_est
